<p>
    Being <b>cool</b> is a boon to programming languages and frameworks and libraries alike.
</p>
<p>
    Being a software developer is cool now! Being a nerd is in!
</p>
<p>
    You wouldn't want to get caught using an uncool technology 
    when you're trying to brag to your friends.
</p>

<h2>The different flavors of cool</h2>

<p>
    There are a few different flavors of cool which might contribute to your street cred.
</p>

<h3>The new hotness</h3>

<p>
    This is the technology that just seems to explode onto the scene overnight. 
    Everyone and their mother are learning it and trying to wedge it into their production systems.
</p>

<p>
    <b>The risk: </b>
    Everyone and their mothers are learning it. 
    It may seem prudent to focus all of your efforts on this next big thing 
    but everyone else is thinking the same way.
    If everyone learns it, it isn't going to differentiate you from the crowd.
    The problems and shortcomings also haven't had time to show up.
</p>

<h3>The you probably haven't heard of it factor</h3>

<p>
    This is the hipster technology that is in complete obscurity. 
    It could have been invented 3 months or 40 years ago.
    It conveys knowing something most other people do not. 
</p>

<p>
    <b>The risk: </b>
    There are reasons old things remain obscure. 
    They either solve a niche problem domain or they never brought anything new to the game.
    There are reasons obscure technologies aren't going to land you tons of job offers: 
    there aren't enough people to employ and there isn't enough community support.
</p>

<h3>The low level factor</h3>

<p>
    I've never quite understood this factor. 
    I think it boils down to feeling superior because low level things are "harder".
    Justifications usually amount to having more discrete control over what runs.
    There is a lot less fluff and garbage. 
    Anyways, if you were a true programmer you would be able to handle the difficult parts.
</p>

<div class="center-content">
    <img src="/img/web-with-assembly.jpg" height="264" width="200" />
</div>

<p>
    <b>The risk: </b>
    There are reasons high level technologies exist. 
    We think in high level ways and have difficulty with low level mediums. 
    The low level technologies often force you to manage a lot of boilerplate code.
    It is often not prudent to stake high level ideas on low level implementations.
</p>

<h2>Let your problem choose
</h2>

<p>
    Choose your technologies based on how well they solve your problem.
</p>

<p>
    Your problem might be scoring a job, 
    so choose technologies that will help you become gainfully employed.
    Your problem might be scaling out low level telecom, 
    so choose languages designed with that in mind.
    Your problem might involve proprietary products which focus on business rules,
    so choose technologies with that in mind.
    Your problem might involve solving a lot of different problems 
    well enough with a limited toolset for consulting,
    so choose technologies with that in mind.
</p>

<p>
    Don't treat every problem as a nail. 
    Don't get caught in the trap of analysis paralysis 
    because at some point you need to get real work done.
    Just take a moment to drop the hammer and think about the situation.
    Choosing something because it's cool won't help you later on.
    Choosing something because it kicks your problem's ass will.
</p>

<p>
    On that note, don't avoid something because you have heard it isn't cool.
</p>
